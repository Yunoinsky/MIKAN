diff --git a/configuration/makefile.in b/configuration/makefile.in
index d92e1b4..36dd75c 100644
--- a/configuration/makefile.in
+++ b/configuration/makefile.in
@@ -35,3 +35,4 @@ LIB_HID ?= 1
 LIB_KBD ?= 1
 LIB_HUB ?= 1
 LIB_MOUSE ?= 1
+LIB_GAMEPAD ?= 1
diff --git a/include/device/hid/gamepad.h b/include/device/hid/gamepad.h
new file mode 100644
index 0000000..cc88b2a
--- /dev/null
+++ b/include/device/hid/gamepad.h
@@ -0,0 +1,29 @@
+#ifndef GAMEPAD_H_
+#define GAMEPAD_H_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <usbd/device.h>
+#include <types.h>
+
+struct GamepadDevice {
+    struct UsbDriverDataHeader Header;
+    u32 Index;
+    struct HidParserReport *InputReport;
+};
+
+#define DeviceDriverGamepad 0x4a4b4c3d
+
+u32 GamepadCount();
+u32 GamepadGetAddress(u32 index);
+u32 GamepadIndex(u32 address);
+Result GamepadPoll(u32 gamepadAddress);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/source/configuration.c b/source/configuration.c
index baca685..db7f72f 100644
--- a/source/configuration.c
+++ b/source/configuration.c
@@ -39,6 +39,9 @@ void KbdLoad();
 #ifdef LIB_MOUSE
 void MouseLoad();
 #endif
+#ifdef LIB_GAMEPAD
+void GamepadLoad();
+#endif
 
 void ConfigurationLoad() {
 	// Call each libraries load method here. Watch out for the order, load more
@@ -66,4 +69,7 @@ void ConfigurationLoad() {
 #ifdef LIB_MOUSE
 	MouseLoad();
 #endif
-}
\ No newline at end of file
+#ifdef LIB_GAMEPAD
+	GamepadLoad();
+#endif
+}
diff --git a/source/device/hid/gamepad.c b/source/device/hid/gamepad.c
new file mode 100644
index 0000000..975628d
--- /dev/null
+++ b/source/device/hid/gamepad.c
@@ -0,0 +1,184 @@
+#include <device/hid/hid.h>
+#include <device/hid/gamepad.h>
+#include <device/hid/report.h>
+#include <platform/platform.h>
+#include <types.h>
+#include <usbd/device.h>
+#include <usbd/usbd.h>
+
+#define GamepadMaxGamepads 4
+
+u32 gamepadCount __attribute__((aligned(4))) = 0;
+u32 gamepadAddresses[GamepadMaxGamepads] = { 0 };
+struct UsbDevice* gamepads[GamepadMaxGamepads];
+
+Result GamepadAttach(struct UsbDevice *device, u32 interface);
+
+void GamepadLoad()
+{
+    LOG_DEBUG("CSUD: Gamepad driver version 0.1\n");
+    gamepadCount = 0;
+    for (u32 i = 0; i < GamepadMaxGamepads; i++)
+    {
+        gamepadAddresses[i] = 0;
+        gamepads[i] = NULL;
+    }
+    HidUsageAttach[DesktopGamePad] = GamepadAttach;
+}
+
+u32 GamepadIndex(u32 address)
+{
+    if (address == 0) return 0xffffffff;
+
+    for (u32 i = 0; i < gamepadCount; i++)
+        if (gamepadAddresses[i] == address)
+            return i;
+
+    return 0xffffffff;
+}
+
+u32 GamepadGetAddress(u32 index) {
+    if (index > gamepadCount) return 0;
+
+    for (u32 i = 0; index >= 0 && i < GamepadMaxGamepads; i++) {
+        if (gamepadAddresses[i] != 0)
+            if (index-- == 0)
+                return gamepadAddresses[i];
+    }
+
+    return 0;
+}
+
+void GamepadDetached(struct UsbDevice *device) {
+    struct GamepadDevice *data;
+
+    data = (struct GamepadDevice*)((struct HidDevice*)device->DriverData)->DriverData;
+    if (data != NULL) {
+        if (gamepadAddresses[data->Index] == device->Number) {
+            gamepadAddresses[data->Index] = 0;
+            gamepadCount--;
+            gamepads[data->Index] = NULL;
+        }
+    }
+}
+
+void GamepadDeallocate(struct UsbDevice *device) {
+    struct GamepadDevice *data;
+
+    data = (struct GamepadDevice*)((struct HidDevice*)device->DriverData)->DriverData;
+    if (data != NULL) {
+        MemoryDeallocate(data);
+        ((struct HidDevice*)device->DriverData)->DriverData = NULL;
+    }
+    ((struct HidDevice*)device->DriverData)->HidDeallocate = NULL;
+    ((struct HidDevice*)device->DriverData)->HidDetached = NULL;
+}
+
+Result GamepadAttach(struct UsbDevice *device, u32 interface)
+{
+    LOG("GP: QwQ!!!!!\n");
+    u32 gamepadNumber;
+    struct HidDevice *hidData;
+    struct GamepadDevice *data;
+    struct HidParserResult *parse;
+
+    if (gamepadCount == GamepadMaxGamepads) {
+        LOGF("GP: %s not connected. Too many gamepads connected (%d/%d). Change GamepadMaxGamepads in device.gamepad.c to allow more.\n", UsbGetDescription(device), gamepadCount, GamepadMaxGamepads);
+        return ErrorIncompatible;
+    }
+
+    hidData = (struct HidDevice*)device->DriverData;
+    if (hidData->Header.DeviceDriver != DeviceDriverHid) {
+        LOGF("GP: %s isn't a HID device. The gamepad driver is built upon the HID driver.\n", UsbGetDescription(device));
+        return ErrorIncompatible;
+    }
+
+    hidData = (struct HidDevice*)device->DriverData;
+    if (hidData->Header.DeviceDriver != DeviceDriverHid) {
+        LOGF("GP: %s isn't a HID device. The gamepad driver is built upon the HID driver.\n", UsbGetDescription(device));
+        return ErrorIncompatible;
+    }
+
+    parse = hidData->ParserResult;
+    if ((parse->Application.Page != GenericDesktopControl && parse->Application.Page != Undefined) ||
+        parse->Application.Desktop != DesktopGamePad) {
+        LOGF("GP: %s doesn't seem to be a gamepad (%x != %x || %x != %x)...\n", UsbGetDescription(device), parse->Application.Page, GenericDesktopControl, parse->Application.Desktop, DesktopGamePad);
+        return ErrorIncompatible;
+    }
+    if (parse->ReportCount < 1) {
+        LOGF("GP: %s doesn't have enough outputs to be a gamepad.\n", UsbGetDescription(device));
+        return ErrorIncompatible;
+    }
+    hidData->HidDetached = GamepadDetached;
+    hidData->HidDeallocate = GamepadDeallocate;
+    if ((hidData->DriverData = MemoryAllocate(sizeof(struct GamepadDevice))) == NULL) {
+        LOGF("GP: Not enough memory to allocate gamepad %s.\n", UsbGetDescription(device));
+        return ErrorMemory;
+    }
+    data = (struct GamepadDevice*)hidData->DriverData;
+    data->Header.DeviceDriver = DeviceDriverGamepad;
+    data->Header.DataSize = sizeof(struct GamepadDevice);
+    data->Index = gamepadNumber = 0xffffffff;
+    for (u32 i = 0; i < GamepadMaxGamepads; i++) {
+        if (gamepadAddresses[i] == 0) {
+            data->Index = gamepadNumber = i;
+            gamepadAddresses[i] = device->Number;
+            gamepadCount++;
+            break;
+        }
+    }
+
+    if (gamepadNumber == 0xffffffff) {
+        LOG("GP: PANIC! Driver in inconsistent state! GamepadCount is inaccurate.\n");
+        GamepadDeallocate(device);
+        return ErrorGeneral;
+    }
+
+    gamepads[gamepadNumber] = device;
+    data->InputReport = NULL;
+
+    for (u32 i = 0; i < parse->ReportCount; i++) {
+        struct HidParserReport *r = parse->Report[i];
+        //LOG_DEBUGF("GP: type %x report %d. %d fields.\n", r->Type, i, r->FieldCount);
+        if (r->Type == Input && data->InputReport == NULL) {
+            LOG_DEBUGF("GP: Report %d identified as input.\n", i);
+            data->InputReport = r;
+        }
+    }
+
+    LOG_DEBUGF("GP: New gamepad assigned %d (%d)!\n", device->Number, gamepadNumber);
+    return OK;
+}
+
+u32 GamepadCount()
+{
+    return gamepadCount;
+}
+
+Result GamepadPoll(u32 gamepadAddress)
+{
+    u32 gamepadNumber;
+    Result result;
+    struct GamepadDevice *data;
+    
+    gamepadNumber = GamepadIndex(gamepadAddress);    
+    if (gamepadNumber == 0xffffffff) return ErrorDisconnected;
+    data = (struct GamepadDevice*)((struct HidDevice*)gamepads[gamepadNumber]->DriverData)->DriverData;
+    if ((result = HidReadDevice(gamepads[gamepadNumber], data->InputReport->Index)) != OK) {
+        if (result != ErrorDisconnected)
+            LOGF("GP: Could not get report from %s.\n", UsbGetDescription(gamepads[gamepadNumber]));
+        return result;
+    }
+
+    for (u32 j = 0; j < data->InputReport->FieldCount; j++) {
+        struct HidParserField *f = &data->InputReport->Fields[j];
+        /*LOG_DEBUGF("GP: F %d Attr = %x Usage = %x%c [%d]",
+            j,
+            *(u32 *)&f->Attributes, *(u32 *)&f->Usage,
+            j % 2 == 0 ? ' ' : '\n', f->Value.U32);*/
+        LOG_DEBUGF("%d%c", f->Value.U32, j % 16 == 15 ? '\n' : ' ');
+    }
+    LOG_DEBUG("\n");
+
+    return OK;
+}
diff --git a/source/device/hid/hid.c b/source/device/hid/hid.c
index 1370af3..5b11d01 100644
--- a/source/device/hid/hid.c
+++ b/source/device/hid/hid.c
@@ -915,6 +915,11 @@ Result HidAttach(struct UsbDevice *device, u32 interfaceNumber) {
 	reportDescriptor = NULL;
 
 	data->ParserResult->Interface = interfaceNumber;
+	if (data->ParserResult->Application.Page == GenericDesktopControl) {
+            LOGF("HID: type = %d\n", (u16)data->ParserResult->Application.Desktop);
+        } else {
+            LOGF("HID: page = %d\n", data->ParserResult->Application.Page);
+        }
 	if (data->ParserResult->Application.Page == GenericDesktopControl &&
 		(u16)data->ParserResult->Application.Desktop < HidUsageAttachCount &&
 		HidUsageAttach[(u16)data->ParserResult->Application.Desktop] != NULL) {
@@ -930,4 +935,4 @@ deallocate:
 
 s32 HidGetFieldValue(struct HidParserField *field, u32 index) {
 	return BitGetSigned(field->Value.Pointer, index * field->Size, field->Size);
-}
\ No newline at end of file
+}
diff --git a/source/device/hid/makefile.in b/source/device/hid/makefile.in
index 82c8ae2..17424ab 100644
--- a/source/device/hid/makefile.in
+++ b/source/device/hid/makefile.in
@@ -24,3 +24,12 @@ $(BUILD)mouse.c.o: $(DIR)mouse.c $(INCDIR)device/hid/hid.h $(INCDIR)device/hid/m
 	@$(GCC) $< -o $@
 	@echo "==== Generating object: $@"
 endif
+
+ifeq ("$(LIB_GAMEPAD)", "1")
+CFLAGS += -DLIB_GAMEPAD
+OBJECTS += $(BUILD)gamepad.c.o
+
+$(BUILD)gamepad.c.o: $(DIR)gamepad.c $(INCDIR)device/hid/hid.h $(INCDIR)device/hid/gamepad.h $(INCDIR)device/hid/report.h $(INCDIR)platform/platform.h $(INCDIR)usbd/device.h $(INCDIR)types.h $(INCDIR)usbd/usbd.h
+	@$(GCC) $< -o $@
+	@echo "==== Generating object: $@"
+endif
diff --git a/source/hcd/dwc/designware20.c b/source/hcd/dwc/designware20.c
index a8e4c8b..62dd4e4 100644
--- a/source/hcd/dwc/designware20.c
+++ b/source/hcd/dwc/designware20.c
@@ -500,7 +500,10 @@ Result HcdSumbitControlMessage(struct UsbDevice *device,
 	struct UsbPipeAddress pipe, void* buffer, u32 bufferLength,
 	struct UsbDeviceRequest *request) {
 	Result result;
-	struct UsbPipeAddress tempPipe;
+	static volatile struct UsbDeviceRequest qwqreq __attribute__((section(".bss.dmem")));
+	static volatile struct UsbPipeAddress tempPipe __attribute__((section(".bss.dmem")));
+	qwqreq = *request;
+	request = (struct UsbDeviceRequest *)&qwqreq;
 	if (pipe.Device == RootHubDeviceNumber) {
 		return HcdProcessRootHubMessage(device, pipe, buffer, bufferLength, request);
 	}
@@ -516,7 +519,7 @@ Result HcdSumbitControlMessage(struct UsbDevice *device,
 	tempPipe.Type = Control;
 	tempPipe.Direction = Out;
 	
-	if ((result = HcdChannelSendWait(device, &tempPipe, 0, request, 8, request, Setup)) != OK) {		
+	if ((result = HcdChannelSendWait(device, (struct UsbPipeAddress *)&tempPipe, 0, request, 8, request, Setup)) != OK) {		
 		LOGF("HCD: Could not send SETUP to %s.\n", UsbGetDescription(device));
 		return OK;
 	}
@@ -533,7 +536,7 @@ Result HcdSumbitControlMessage(struct UsbDevice *device,
 		tempPipe.Type = Control;
 		tempPipe.Direction = pipe.Direction;
 		
-		if ((result = HcdChannelSendWait(device, &tempPipe, 0, databuffer, bufferLength, request, Data1)) != OK) {		
+		if ((result = HcdChannelSendWait(device, (struct UsbPipeAddress *)&tempPipe, 0, databuffer, bufferLength, request, Data1)) != OK) {		
 			LOGF("HCD: Could not send DATA to %s.\n", UsbGetDescription(device));
 			return OK;
 		}
@@ -566,7 +569,7 @@ Result HcdSumbitControlMessage(struct UsbDevice *device,
 	tempPipe.Type = Control;
 	tempPipe.Direction = ((bufferLength == 0) || pipe.Direction == Out) ? In : Out;
 	
-	if ((result = HcdChannelSendWait(device, &tempPipe, 0, databuffer, 0, request, Data1)) != OK) {		
+	if ((result = HcdChannelSendWait(device, (struct UsbPipeAddress *)&tempPipe, 0, databuffer, 0, request, Data1)) != OK) {		
 		LOGF("HCD: Could not send STATUS to %s.\n", UsbGetDescription(device));
 		return OK;
 	}
diff --git a/source/platform/platform.c b/source/platform/platform.c
index 4d46c66..8adc970 100644
--- a/source/platform/platform.c
+++ b/source/platform/platform.c
@@ -29,8 +29,8 @@ struct HeapAllocation {
 	struct HeapAllocation *Next;
 };
 
-u8 Heap[0x4000] __attribute__((aligned(8))); // Support a maximum of 16KiB of allocations
-struct HeapAllocation Allocations[0x100]; // Support 256 allocations
+u8 Heap[0x40000] __attribute__((aligned(8), section(".bss.dmem"))); // Support a maximum of 16KiB of allocations
+struct HeapAllocation Allocations[0x1000]; // Support 4096 allocations
 struct HeapAllocation *FirstAllocation = HEAP_END, *FirstFreeAllocation = NULL;
 u32 allocated = 0;
 
@@ -73,7 +73,7 @@ void* MemoryAllocate(u32 size) {
 				Next->Next = Current->Next;
 				Current->Next = Next;
 				allocated += size;
-				LOG_DEBUGF("Platform: malloc(%#x) = %#x. (%d/%d)\n", size, Next->Address, allocated, sizeof(Heap));
+				//LOG_DEBUGF("Platform: malloc(%#x) = %#x. (%d/%d)\n", size, Next->Address, allocated, sizeof(Heap));
 				return Next->Address;
 			}
 			else
@@ -93,7 +93,7 @@ void* MemoryAllocate(u32 size) {
 				Next->Next = Current->Next;
 				Current->Next = Next;
 				allocated += size;
-				LOG_DEBUGF("Platform: malloc(%#x) = %#x. (%d/%d)\n", size, Next->Address, allocated, sizeof(Heap));
+				//LOG_DEBUGF("Platform: malloc(%#x) = %#x. (%d/%d)\n", size, Next->Address, allocated, sizeof(Heap));
 				return Next->Address;
 			}
 			else {
@@ -448,4 +448,4 @@ void PlatformLoad()
 	FirstAllocation = HEAP_END;
 	FirstFreeAllocation = NULL;
 #endif
-}
\ No newline at end of file
+}
diff --git a/source/usbd/usbd.c b/source/usbd/usbd.c
index c0c1ebd..c5a1fc6 100644
--- a/source/usbd/usbd.c
+++ b/source/usbd/usbd.c
@@ -644,4 +644,4 @@ void csudUsbCheckForChange() {
 	if (Devices[0] != NULL &&
 		Devices[0]->DeviceCheckForChange != NULL)
 		Devices[0]->DeviceCheckForChange(Devices[0]);
-}
\ No newline at end of file
+}
